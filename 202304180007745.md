# 基础算法

## 排序

模板题：[912. 排序数组](https://leetcode.cn/problems/sort-an-array/)

### 快速排序

快速排序是基于分治的算法：

- 从数组中选取中轴元素 pivot
- 将小元素放在 pivot 左边，大元素放右边
- 然后分别对左边和右边的子数组进行快排

例题：
[215. 数组中的第 K 个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/description/)

```java
public class Main {
    public static void quickSort(int[] q, int l, int r) {
        if (l >= r) return;
        int x = q[l + r >> 1], i = l - 1, j = r + 1;
        while (i < j) {
            while (q[++i] < x) ;
            while (q[--j] > x) ;
            if (i < j) {
                int t = q[i];
                q[i] = q[j];
                q[j] = t;
            }
        }
        quickSort(q, l, j);
        quickSort(q, j + 1, r);
    }
}
```

```java
class Solution {
    public int[] sortArray(int[] nums) {
        quickSort(nums, 0, nums.length - 1);
        return nums;
    }

    public void quickSort(int[] arr, int l, int r) {
        if (l >= r) return;
        int pivot = partition(arr, l, r);
        quickSort(arr, l, pivot - 1);
        quickSort(arr, pivot + 1, r);
    }
    // partition函数：确定pivot，并调配好pivot左右的数组，返回pivot
    public int partition(int[] arr, int l, int r) {
        int randomIdx = l + (int)(Math.random() * (r - l + 1));
        swap(arr, randomIdx, r);
        int pivotVal = arr[r];
        // i表示比pivotVal小的元素的下标
        int i = l - 1;
        // for循环的意义是把比pivotVal小的元素移到前面
        for (int j = l; j <= r - 1; j++) {
            if (arr[j] < pivotVal) {
                i++;
                swap(arr, j, i);
            }
        }
        swap(arr, i + 1, r);
        return i + 1;
    }

    public void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

### 归并排序

归并排序是基于分治的排序算法
原问题：把数组排序
子问题：把数组前一半、后一半分别排序，然后再合并两半
例题：[剑指 Offer 51. 数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/description/)

```java
public class Sort {
    public void mergeSort(int[] arr, int l, int r) {
        if (l >= r) return;
        int mid = (l + r) / 2;
        mergeSort(arr, l, mid);
        mergeSort(arr, mid + 1, r);
        merge(arr, l, mid, r);
    }

    private void merge(int[] arr, int l, int mid, int r) {
        int[] temp = new int[r - l + 1];
        int i = l, j = mid + 1, idx = 0;
        while (i <= mid && j <= r) {
            if (arr[i] <= arr[j]) temp[idx++] = arr[i++];
            else temp[idx++] = arr[j++];
        }
        while (i <= mid) temp[idx++] = arr[i++];
        while (j <= r) temp[idx++] = arr[j++];
        for (int k = 0; k < temp.length; k++) {
            arr[l + k] = temp[k];
        }
    }
}
```

### 堆排序

例题：[Heap Sort](https://www.algoexpert.io/questions/heap-sort)

```java
import java.util.*;

class Program {
    static int endIdx;

    public static int[] heapSort(int[] array) {
        int n = array.length;
        int[] heap = array;
        endIdx = n - 1;
        // O(n)建堆方式，从倒数第一个非叶子节点开始heapifyDown
        for (int i = (n - 1) / 2; i >= 0; i--) {
            heapifyDown(heap, i);
        }
        int[] ans = new int[n];
        for (int i = 0; i < n; i++) {
            ans[i] = heap[0];
            heap[0] = heap[endIdx];
            endIdx--;
            heapifyDown(heap, 0);
        }
        return ans;
    }

    public static void heapifyDown(int[] heap, int idx) {
        // 找到自己、左孩子、右孩子三者的最小值，即要交换到的目标下标
        int t = idx;
        if (2 * idx + 1 <= endIdx && heap[2 * idx + 1] < heap[t])
            t = 2 * idx + 1;
        if (2 * idx + 2 <= endIdx && heap[2 * idx + 2] < heap[t])
            t = 2 * idx + 2;
        if (idx != t) {
            int temp = heap[idx];
            heap[idx] = heap[t];
            heap[t] = temp;
            heapifyDown(heap, t);
        }
    }
}

```

```java
class Solution {
    public void heapSort(int[] arr) {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        int n = arr.length;
        for (int num : arr) {
            pq.offer(num);
        }
        for (int i = 0; i < n; i++) {
            arr[i] = pq.peek();
            pq.poll();
        }
    }
}
```

## 二分

### 经典二分

```java
class Solution {
    public int search(int[] nums, int target) {
        if (target < nums[0] || target > nums[nums.length - 1]) {
            return -1;
        }

        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1;
            else if (nums[mid] > target)
                right = mid - 1;
        }
        return -1;
    }
}
```

### 后继型二分

查找第一个 `>=target` 的数的下标，不存在则返回 n。（后继型）

```java
class Solution {
    public int search(int[] nums, int target) {
        // nums.length是保护节点，由于往下取整永远不会被访问到，如果最后返回nums.length则表示无解
        int left = 0, right = nums.length;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] >= target) { // 条件被满足的一侧应该被包含
                right = mid;
            } else {
                left = mid + 1; // 条件不满足的一侧直接去掉
            }
        }
        return right;
    }
}
```

### 前驱型二分

查找最后一个 `<= target` 的数的下标，不存在则返回 -1。（前驱型）

```java
class Solution {
    public int search(int[] nums, int target) {
        // -1是保护节点，由于向上取整永远不会被访问到，如果最后返回-1则表示无解
        int left = -1, right = nums.length - 1;
        while (left < right) {
            int mid = left + (right - left + 1) / 2; // 向上取整，避免陷入死循环
            if (nums[mid] <= target) { // 条件被满足的一侧应该被包含
                left = mid;
            } else {
                right = mid - 1; // 条件不满足的一侧直接去掉
            }
        }
        return right;
    }
}
```

## 双指针

```java
for (i = 0, j = 0; i < n; i++) {
    while (j < i && check(i, j)) j++;
    // 主要逻辑
}
```

例题：利用双指针实现 `String.split(" ")`

```java
public class Main {
    public static void main(String[] args) {
        String s = "abc def ghi";
        char[] arr = s.toCharArray();
        int n = s.length();
        for (int i = 0; i < n; i++) {
            int j = i;
            while (j < n && arr[j] != ' ') j++;
            for (int k = i; k < j; k++) System.out.print(arr[k]);
            System.out.println();
            i = j;
        }
    }
}
```

例题：[3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/)

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (s.length()==0) return 0;
        HashMap<Character, Integer> map = new HashMap<>();
        int ans = 0;
        int left = 0;
        for (int i = 0; i < s.length(); i++) {
            map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) + 1);
            while (map.get(s.charAt(i)) > 1) {
                map.put(s.charAt(left), map.get(s.charAt(left)) - 1);
                left++;
            }
            ans = Math.max(ans, i - left + 1);
        }
        return ans;
    }
}
```

## 位运算

例题：[801. 二进制中 1 的个数](https://www.acwing.com/problem/content/description/803/), [剑指 Offer 15.  二进制中 1 的个数](https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/description/?orderBy=hot)
对于每个数字 a，`a&1`得到了该数字的最后一位，之后将 a 右移一位，直到为 0，就得到了 1 的个数

```java
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        String[] s = br.readLine().split(" ");
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = Integer.parseInt(s[i]);
        }
        // main logic
        for (int i = 0; i < n; i++) {
            int count = 0;
            while (nums[i] > 0) {
                count += nums[i] & 1;
                nums[i] = nums[i] >> 1;
            }
            System.out.print(count + " ");
        }
    }
}
```

```java
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        String[] s = br.readLine().split(" ");
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = Integer.parseInt(s[i]);
        }
        // main logic
        for (int x : nums) {
            int count = 0;
            while (x > 0) {
                x -= lowbit(x);
                count++;
            }
            System.out.print(count + " ");
        }
    }

    private static int lowbit(int x) {
        return x & -x;
    }
}
```

`lowbit(x)`：返回 x 的最后一位 1 及之后的数
热知识：`-x = ~x + 1`

| `x的二进制表示` | `lowbit(x)` |
| --------------- | ----------- |
| 1010            | 10          |
| 101000          | 1000        |

`lowbit(x) = x & -x = x & (~x + 1)`

## 离散化

离散化的本质是建立了一段数列到自然数之间的映射关系（value -> index)，通过建立新索引，来缩小目标区间，使得可以进行一系列连续数组可以进行的操作比如二分，前缀和等。
小技巧：Java 中对数据进行排序+去重可以使用`TreeSet`。
⭐ 例题：[802. 区间和](https://www.acwing.com/problem/content/804/)

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt();//n次操作
        int m = scan.nextInt();//m次询问

        TreeSet<Integer> set = new TreeSet<>();//用来存所有的下标：x,l,r; TreeSet实现排序+去重
        List<Pair> add = new ArrayList<>();//用来存n次操作
        List<Pair> query = new ArrayList<>();//用来存m次询问
        //输入n次操作，每次操作存入add集合中，然后将下标x存入set集合中
        for (int i = 0; i < n; i++) {
            int x = scan.nextInt();
            int c = scan.nextInt();
            add.add(new Pair(x, c));
            set.add(x);
        }
        //输入m次询问，每次询问存入query集合中，因为l,r是求和的下标区间和，所以l,r都存入set集合中。
        for (int i = 0; i < m; i++) {
            int l = scan.nextInt();
            int r = scan.nextInt();
            query.add(new Pair(l, r));
            set.add(l);
            set.add(r);
        }

        ArrayList<Integer> alls = new ArrayList<>(set);  //set转换为ArrayList，方便对下标进行二分查找。
        int[] a = new int[alls.size() + 1]; //用来存储排序、去重后的数组，因为要用到前缀和，所以0不操作；
        int[] s = new int[alls.size() + 1];//用来存前缀和，从1开始进行记录a数组；

        for (Pair pair : add) {
            int index = find(pair.first, alls);
            a[index] += pair.second;
        }

        for (int i = 1; i <= alls.size(); i++) s[i] = s[i - 1] + a[i]; //这是前缀和公式代码

        for (Pair pair : query) {
            int l = find(pair.first, alls);
            int r = find(pair.second, alls);
            System.out.println(s[r] - s[l - 1]);
        }

    }

    //二分查找（在集合中查找你现在的下标是在什么位置，因为需要符合我们要用的前缀和公式，要让下标不是从0输出，最低的下标是1，符合前缀和的从1开始，所以输出的值加1）
    public static int find(int x, List<Integer> list) {
        int l = 0;
        int r = list.size() - 1;
        while (l < r) {
            int mid = l + r >> 1;
            if (list.get(mid) >= x) r = mid;
            else l = mid + 1;
        }
        return r + 1;
    }
}

//这是一个Pair类，用来存操作的类
class Pair {
    int first;
    int second;

    public Pair(int x, int c) {
        this.first = x;
        this.second = c;
    }
}

```

## 区间合并

[56. 合并区间](https://leetcode.cn/problems/merge-intervals/description/)
由于每次比较区间都是和数组的最后一个区间比较，因此也可以用`LinkedList`或者`Stack`存答案数组

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        // 先按照区间起始位置排序
        Arrays.sort(intervals, (v1, v2) -> v1[0] - v2[0]);
        // 遍历区间
        int[][] res = new int[intervals.length][2];
        int idx = -1;
        for (int[] interval: intervals) {
            // 如果结果数组是空的，或者当前区间的起始位置 > 结果数组中最后区间的终止位置，
            // 则不合并，直接将当前区间加入结果数组。
            if (idx == -1 || interval[0] > res[idx][1]) {
                res[++idx] = interval;
            } else {
                // 反之将当前区间合并至结果数组的最后区间
                res[idx][1] = Math.max(res[idx][1], interval[1]);
            }
        }
        return Arrays.copyOf(res, idx + 1);
    }
}
```

# 数据结构

## 单调栈

例题：[830. 单调栈](https://www.acwing.com/problem/content/832/)

> 给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = sc.nextInt();
        }
        Deque<Integer> stack = new ArrayDeque<>();
        for (int i = 0; i < n; i++) {
            while (!stack.isEmpty() && stack.peek() >= nums[i]) {
                stack.pop();
            }
            if (stack.isEmpty()) System.out.print(-1 + " ");
            else System.out.print(stack.peek() + " ");
            stack.push(nums[i]);
        }
    }
}
```

## 单调队列

⭐ 例题：[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/description/)
思路：如果窗口中有 2 个元素下标为`i`和`j`(i < j)，并且`nums[i] < nums[j]`，那么`nums[i]`就没有存在的必要了（因为`nums[i]`既比`nums[j]`小，又比`nums[j]`先出队）。基于这个结论，我们就可以动态维护一个单调递减的单调队列。

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int[] ans = new int[nums.length - k + 1];
        // 双端队列，存元素的下标，队列左端是头，右端是尾
        Deque<Integer> q = new ArrayDeque<>();
        for (int i = 0; i < nums.length; i++) {
            // 删除出界的元素(即队头的元素已经不在窗口中了)
            while (!q.isEmpty() && q.peekFirst() <= i - k) {
                q.pollFirst();
            }
            // 维护队列单调性，插入新的选项（遇到破坏单调性的元素直接poll到保持单调性为止）
            while (!q.isEmpty() && nums[q.peekLast()] <= nums[i]) {
                q.pollLast();
            }
            q.offerLast(i);
            // i从 k-1 开始每次取队头更新答案
            if (i >= k - 1) {
                ans[i - (k - 1)] = nums[q.peekFirst()];
            }
        }
        return ans;
    }
}
```

时间复杂度：`O(n)`，每一个下标恰好被放入队列一次，并且最多被弹出队列一次
空间复杂度：`O(k)`

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        // 大根堆存[值，下标]
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[0] - a[0]);
        int[] ans = new int[nums.length - k + 1];
        for (int i = 0; i < nums.length; i++) {
            pq.offer(new int[]{nums[i], i});
            // 初始化到窗口长度为k的时候才开始更新答案
            if (i >= k - 1) {
                // 懒惰删除，检查堆顶的元素的下标是否在窗口中
                while (pq.peek()[1] <= i - k) pq.poll();
                ans[i - k + 1] = pq.peek()[0];
            }
        }
        return ans;
    }
}
```

时间复杂度：`O(nlogn)`，最差情况数组单调递增，没有元素被弹出，入堆操作为`logn`
空间复杂度：`O(n)`

## Trie

例题：[208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/description/), [720. 词典中最长的单词](https://leetcode.cn/problems/longest-word-in-dictionary/), [212. 单词搜索 II](https://leetcode.cn/problems/word-search-ii/)
如果题目说明了只有小写英文字母的话，可以用数组代替哈希表实现

```java
class Trie {

    class Node {
        int count = 0; //词频
        HashMap<Character, Node> children = new HashMap<>(); //字符映射
    }

    Node root;

    public Trie() {
        root = new Node();
    }

    public void insert(String word) {
        Node cur = root;
        for (char ch : word.toCharArray()) {
            if (!cur.children.containsKey(ch)) {
                cur.children.put(ch, new Node());
            }
            cur = cur.children.get(ch);
        }
        cur.count++;
    }

    public boolean search(String word) {
        Node cur = root;
        for (char ch : word.toCharArray()) {
            if (!cur.children.containsKey(ch)) {
                return false;
            }
            cur = cur.children.get(ch);
        }
        // 防止insert了"abc"但是要查找"a"的情况
        return cur.count > 0;
    }

    public boolean startsWith(String prefix) {
        Node cur = root;
        for (char ch : prefix.toCharArray()) {
            if (!cur.children.containsKey(ch)) {
                return false;
            }
            cur = cur.children.get(ch);
        }
        return true;
    }
}
```

```java
class Trie {

    Trie[] children;
    boolean isEnd;

    public Trie() {
        children = new Trie[26];
        isEnd = false;
    }

    public void insert(String word) {
        Trie cur = this;
        for (char c : word.toCharArray()) {
            int idx = c - 'a';
            if (cur.children[idx] == null) {
                cur.children[idx] = new Trie();
            }
            cur = cur.children[idx];
        }
        cur.isEnd = true;
    }

    public boolean search(String word) {
        Trie cur = this;
        for (char c : word.toCharArray()) {
            int idx = c - 'a';
            if (cur.children[idx] == null) {
                return false;
            }
            cur = cur.children[idx];
        }
        return cur.isEnd;
    }

    public boolean startsWith(String prefix) {
        Trie cur = this;
        for (char c : prefix.toCharArray()) {
            int idx = c - 'a';
            if (cur.children[idx] == null) {
                return false;
            }
            cur = cur.children[idx];
        }
        return true;
    }
}
```

## 并查集

例题：[836. 合并集合](https://www.acwing.com/problem/content/838/), [837. 连通块中点的数量](https://www.acwing.com/problem/content/839/), [547. 省份数量](https://leetcode.cn/problems/number-of-provinces/description/)

```java
class UnionFindSet {
    int[] fa;

    public UnionFindSet(int n) {
        fa = new int[n];
        for (int i = 0; i < n; i++) {
            fa[i] = i;
        }
    }

    public int find(int x) {
        if (x != fa[x]) {
            fa[x] = find(fa[x]);
        }
        return fa[x];
    }

    public void union(int x, int y) {
        x = find(x);
        y = find(y);
        if (x != y) {
            fa[x] = y;
        }
    }
}
```

## 堆

如何手写一个小根堆：如果数组下标从 1 开始

1. 插入一个数：`heap[++size] = x; up(size);`
2. 求最小值：`heap[1];`
3. 删除最小值：`heap[1] = heap[size]; size--; down(1);`
4. 删除任意一个元素：`heap[k] = heap[size]; size--; down(k); up(k);`
5. 修改任意一个元素：`heap[k] = x; down(k); up(k);`

例题：[838. 堆排序](https://www.acwing.com/problem/content/840/)

```java
import java.util.*;

class Main {

    static int size;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int[] heap = new int[n + 1];
        size = n;
        // heap下标从1开始
        for (int i = 1; i <= n; i++) {
            heap[i] = sc.nextInt();
        }
        // O(n)建堆方式，从倒数第一个非叶子节点开始heapifyDown
        for (int i = n / 2; i >= 1; i--) heapifyDown(heap, i);
        while (m-- > 0) {
            System.out.print(heap[1] + " ");
            heap[1] = heap[size];
            size--;
            heapifyDown(heap, 1);
        }
    }

    public static void heapifyDown(int[] heap, int idx) {
        // 找到自己、左孩子、右孩子三者的最小值，即要交换到的目标下标
        int t = idx;
        int l = 2 * idx, r = 2 * idx + 1;
        if (l <= size && heap[l] < heap[t])
            t = l;
        if (r <= size && heap[r] < heap[t])
            t = r;
        if (idx != t) {
            int temp = heap[idx];
            heap[idx] = heap[t];
            heap[t] = temp;
            heapifyDown(heap, t);
        }
    }
}
```

## 字符串哈希

字符串哈希算法：[AcWing 841. 字符串哈希 【公式助理解】](https://www.acwing.com/solution/content/24738/)
在 Java 中，字符串 s 的 `hashcode()` 方法的实现为：
$s[0]*31^{n - 1} + s[1]*31^{n - 2} + ... + s[n - 1]$
`s[0] ... s[n-1]`代表 s 的下标为 i 处的字符的 ASCII 值，hashcode 计算方式是把整个长度为 n 的字符串看作一个位数为 n 的 31 进制数，hashcode 就是这个 31 进制数代表的 10 进制数。

```java
import java.util.*;

class Main {
    static int P = 31; // p是进制数
    static long[] h; // 这是存放hash前缀值的数组
    static long[] p; //这是存放p的n次方的数组

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        String s = sc.next();
        h = new long[n + 1];
        p = new long[n + 1];
        p[0] = 1; // p的0次方
        for (int i = 1; i <= n; i++) {
            p[i] = p[i - 1] * P;
            h[i] = h[i - 1] * P + s.charAt(i - 1);
        }
        for (int i = 0; i < m; i++) {
            int l1 = sc.nextInt();
            int r1 = sc.nextInt();
            int l2 = sc.nextInt();
            int r2 = sc.nextInt();
            if (hashcode(l1, r1) == hashcode(l2, r2)) System.out.println("Yes");
            else System.out.println("No");
        }
    }

    public static long hashcode(int l, int r) {
        return h[r] - h[l - 1] * p[r - l + 1];
    }
}
```

# 搜索与图论

网格类搜索模板题：[200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/description/)
图论模板题：[1971. 寻找图中是否存在路径](https://leetcode.cn/problems/find-if-path-exists-in-graph/description/)

## DFS

模板题：[DFS of Graph](https://practice.geeksforgeeks.org/problems/depth-first-traversal-for-a-graph/1?page=1&category[]=Graph&sortBy=submissions)

```java
class Solution {
    ArrayList<Integer> ans;
    ArrayList<ArrayList<Integer>> adj;
    boolean[] visited;

    public ArrayList<Integer> dfsOfGraph(int V, ArrayList<ArrayList<Integer>> adj) {
        ans = new ArrayList<>();
        this.adj = adj;
        visited = new boolean[V];
        dfs(0);
        return ans;
    }

    private void dfs(int s) {
        visited[s] = true;
        ans.add(s);
        for (int t : adj.get(s)) {
            if (!visited[t]){
                dfs(t);
            }
        }
    }
}
```

例题：[200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/description/)

```java
class Solution {
    int[] dx = new int[] {1, 0, -1, 0};
    int[] dy = new int[] {0, -1, 0, 1};
    boolean[][] visited;

    public int numIslands(char[][] grid) {
        int m = grid.length, n = grid[0].length;
        visited = new boolean[m][n];
        int ans = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1' && !visited[i][j]) {
                    dfs(grid, i, j);
                    ans++;
                }
            }
        }
        return ans;
    }

    private void dfs(char[][] grid, int x, int y) {
        if (!inArea(grid, x, y)) return;
        if (grid[x][y] != '1') return;
        if (visited[x][y]) return;
        visited[x][y] = true;
        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];
            dfs(grid, nx, ny);
        }
    }

    private boolean inArea(char[][] grid, int x, int y) {
        int m = grid.length, n = grid[0].length;
        if (x < 0 || x >= m || y < 0 || y >= n) return false;
        return true;
    }
}
```

例题：[Cycle In Graph](https://www.algoexpert.io/questions/cycle-in-graph)
用`visited`记录已经遍历过的节点，用`inStack`记录当前路径上经过的节点。记得回溯。

```java
import java.util.*;

class Program {
    boolean[] visited;
    boolean[] inStack;

    public boolean cycleInGraph(int[][] edges) {
        int n = edges.length;
        visited = new boolean[n];
        inStack = new boolean[n];
        for (int i = 0; i < n; i++) {
            if (dfs(edges, i)) return true;
        }
        return false;
    }

    public boolean dfs(int[][] edges, int node) {
        visited[node] = true;
        inStack[node] = true;
        boolean hasCycle = false;
        for (int u : edges[node]) {
            if (!visited[u]) {
                hasCycle = dfs(edges, u);
            }
            if (visited[u] && inStack[u]) {
                return true;
            }
        }
        inStack[node] = false;
        return false;
    }
}
```

## BFS

模板题：[BFS of graph](https://practice.geeksforgeeks.org/problems/bfs-traversal-of-graph/1?page=1&category[]=Graph&sortBy=submissions)

```java
class Solution {
    public ArrayList<Integer> bfsOfGraph(int V, ArrayList<ArrayList<Integer>> adj) {
        ArrayList<Integer> ans = new ArrayList<>();
        boolean[] visited = new boolean[V];
        Deque<Integer> q = new ArrayDeque<>();
        q.offer(0);
        visited[0] = true;
        while (!q.isEmpty()) {
            int t = q.poll();
            ans.add(t);
            for (int s : adj.get(t)) {
                if (!visited[s]) {
                    q.offer(s);
                    visited[s] = true;
                }
            }
        }
        return ans;
    }
}
```

例题：[847. 图中点的层次](https://www.acwing.com/problem/content/849/)

```java
import java.util.*;

public class Main {
    static List<Integer>[] edges; // 出边数组
    static boolean[] used;
    static int[] distance; // distance[i]表示从bfs的起点到i的距离，本题即bfs(1)返回distance[n]

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        used = new boolean[n + 1];
        distance = new int[n + 1];
        Arrays.fill(distance, -1); // distance[]初始化为不可达
        edges = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            edges[i] = new ArrayList<>();
        }
        for (int i = 0; i < m; i++) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            edges[a].add(b);
        }
        bfs(1);
        System.out.println(distance[n]);
    }

    // 从点u出发的bfs
    public static void bfs(int u) {
        Queue<Integer> q = new ArrayDeque<>();
        q.offer(u);
        used[u] = true;
        distance[u] = 0; // 起点到自己的距离为0
        int d = 1;
        while (!q.isEmpty()) {
            int size = q.size();
            for (int i = 0; i < size; i++) {
                u = q.poll();
                for (int v : edges[u]) {
                    if (!used[v]) {
                        q.offer(v);
                        used[v] = true;
                        distance[v] = d;
                    }
                }
            }
            d++;
        }
    }
}
```

## 拓扑排序

例题：[207. 课程表](https://leetcode.cn/problems/course-schedule/description/?orderBy=most_votes)

> 拓扑排序（Topological Sorting）是一个有向无环图（DAG）的所有顶点的线性序列。拓扑序列是一条满足图中有向边前后关系的序列，任一有向边起点在序列中一定早于终点出现。如果图中有环，则无法提取出拓扑序列。所以拓扑排序的一个重要应用是在给定的有向图中判定是否存在环路。

拓扑排序问题：**常用于判断一个图是否是有向无环图（DAG）**

1. 根据依赖关系，构建邻接表、入度数组。
2. 选取入度为 0 的数据，根据邻接表，减小依赖它的数据的入度。
3. 找出入度变为 0 的数据，重复第 2 步。
4. 直至所有数据的入度为 0，得到排序，如果还有数据的入度不为 0，说明图中存在环。

```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        int n = numCourses;
        // 入度数组
        int[] inDegree = new int[n];
        // 邻接表建图
        List<Integer>[] edges = new List[n];
        for (int i = 0; i < n; i++) {
            edges[i] = new ArrayList<>();
        }
        for (int[] edge : prerequisites) {
            int to = edge[0];
            int from = edge[1];
            inDegree[to]++;
            edges[from].add(to);
        }
        // BFS
        Queue<Integer> q = new ArrayDeque<>();
        // 加入入度为0的节点
        for (int i = 0; i < n; i++) {
            if (inDegree[i] == 0) q.offer(i);
        }
        while (!q.isEmpty()) {
            int t = q.poll();
            for (int i : edges[t]) {
                inDegree[i]--;
                if (inDegree[i] == 0) q.offer(i);
            }
        }
        // 检查是否还有入度不为0的节点
        for (int x : inDegree) {
            if (x != 0) return false;
        }
        return true;
    }
}
```

## Dijkstra 算法

最短路算法模板题：[743. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/description/)
![截屏2022-12-13 10.51.02.png](https://cdn.nlark.com/yuque/0/2022/png/25849280/1671075027014-b28b8d8b-0d67-492b-83c7-a1d96dc0ee94.png#averageHue=%23fdfdfc&clientId=ub0fd1967-6e8f-4&from=paste&height=356&id=ufc932674&name=%E6%88%AA%E5%B1%8F2022-12-13%2010.51.02.png&originHeight=711&originWidth=1582&originalType=binary&ratio=1&rotation=0&showTitle=false&size=336997&status=done&style=none&taskId=u53a28086-e66d-4655-bb35-aab01f8d1a8&title=&width=791)
Dijkstra 算法适用于所有边权都是正数的单源最短路问题。
时间复杂度：`O(n^2)`

Dijkstra 算法是解决单源最短路径问题的贪心算法，它先求出长度最短的一条路径，再参照该最短路径求出长度次短的一条路径，直到求出源点到其他各个节点的最短路径。

Dijkstra 算法基本思想：将节点集合 V 分为两部分：集合 S 和 V-S，其中 S 中的节点的最短路径已经确定，V-S 中的节点的最短路径待定。

从源点出发只经过 S 中的节点到达 V-S 中的节点的路径称为特殊路径。Dikstra 算法的贪心策略是选择最短的特殊路径长度 `dist[t]`，并将节点加入到集合 S 中，同时借助更新数组 `dist[]` 。一旦 S 包含了所有节点，`dist[]` 就是从源点到其他节点的最短路径长度。

Dijkstra 求最短路的思路如下：
如果我们要求节点 1 到节点 n 的单源最短路，

- 用邻接矩阵建图（注意在遍历记录边之前要先把矩阵初始化为正无穷）
- 新建一个 visited 集合，用于保存确定了和 1 号节点的最短距离的点
- 新建 dist 数组，用于记录各个节点与 1 号节点的距离（除 1 号点之外初始化为正无穷）
- 循环 n-1 次，将 n-1 个点加入到 s 集合中
  1.  找到当前距离 1 号节点最近的节点
  2.  将这个节点加入 visited 集合中
  3.  由这个点更新其它节点到 1 号节点的距离

例题：[849. Dijkstra 求最短路 I](https://www.acwing.com/problem/content/851/)

```java
class Solution {
    public int networkDelayTime(int[][] times, int n, int k) {
        final int INF = Integer.MAX_VALUE / 2;
        // 建图，邻接矩阵
        int[][] g = new int[n + 1][n + 1];
        for (int i = 1; i <= n; i++) {
            Arrays.fill(g[i], INF);
        }
        for (int[] t : times) {
            int x = t[0];
            int y = t[1];
            g[x][y] = t[2];
        }
        // 创建dist数组
        int[] dist = new int[n + 1];
        Arrays.fill(dist, INF);
        dist[k] = 0;
        boolean[] visited = new boolean[n + 1];
        for (int i = 1; i <= n; i++) {
            int x = -1;
            for (int y = 1; y <= n; y++) {
                // 每次找到「最短距离最小」且「未被更新」的点x
                if (!visited[y] && (x == -1 || dist[y] < dist[x])) {
                    x = y;
                }
            }
            visited[x] = true;
            for (int y = 1; y <= n; y++) {
                dist[y] = Math.min(dist[y], dist[x] + g[x][y]);
            }
        }
        int ans = 0;
        for (int i = 1; i <= n; i++) {
            ans = Math.max(ans, dist[i]);
        }
        return ans == INF ? -1 : ans;
    }
}
```

堆优化版：
时间复杂度：`O(mlogn)`
例题：[850. Dijkstra 求最短路 II](https://www.acwing.com/problem/content/852/)

```java
import java.util.*;

class Main {
    static int INF = Integer.MAX_VALUE / 2;
    static int n;
    static int m;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        m = sc.nextInt();
        // 稀疏图用邻接表存图
        List<int[]>[] edges = new ArrayList[n + 1];
        for (int i = 0; i <= n; i++) {
            edges[i] = new ArrayList<>();
        }
        while (m-- > 0) {
            int x = sc.nextInt();
            int y = sc.nextInt();
            int z = sc.nextInt();
            edges[x].add(new int[] {y, z});
        }
        System.out.println(dijkstra(edges));
    }

    public static int dijkstra(List<int[]>[] edges) {
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);
        int[] dist = new int[n + 1];
        // 相当于s集合，确定了和1号点的最短距离的点加入到s集合中
        boolean[] st = new boolean[n + 1];
        Arrays.fill(dist, INF);
        pq.offer(new int[] {1, 0});
        dist[1] = 0;
        while (!pq.isEmpty()) {
            int[] cur = pq.poll();
            int ver = cur[0];
            int distance = cur[1];
            if (st[ver]) continue;
            st[ver] = true;
            for (int[] v : edges[ver]) {
                dist[v[0]] = Math.min(dist[v[0]], distance + v[1]);
                pq.offer(new int[] {v[0], dist[v[0]]});
            }
        }
        if (dist[n] == INF) return -1;
        return dist[n];
    }
}
```

## Bellman-Ford 算法

![image.png](https://cdn.nlark.com/yuque/0/2022/png/25849280/1671080546497-dc0f8252-b3d4-42d5-b6dc-69d0fbc694c6.png#averageHue=%23f5f5f5&clientId=ub0fd1967-6e8f-4&from=paste&height=583&id=ua90854ff&name=image.png&originHeight=1166&originWidth=2274&originalType=binary&ratio=1&rotation=0&showTitle=false&size=324946&status=done&style=none&taskId=ucb816c1a-f720-4009-9b9b-f4d0bd0ad33&title=&width=1137)
例题：[743. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/description/) （本题也可以使用 dijkstra 算法解决）
例题：[787. K 站中转内最便宜的航班](https://leetcode.cn/problems/cheapest-flights-within-k-stops/description/?orderBy=most_votes)（**带限制的单源最短路问题**）
[1928. 规定时间内到达终点的最小花费](https://leetcode.cn/problems/minimum-cost-to-reach-destination-in-time/description/?orderBy=most_votes&page=2)

```java
// 单源最短路问题：Bellman-Ford算法
class Solution {
    public int networkDelayTime(int[][] times, int n, int k) {
        // 从1到n的dist数组
        int[] dist = new int[n + 1];
        // 初始化dist数组为无穷大
        Arrays.fill(dist, Integer.MAX_VALUE / 2);
        // 起点到自己的距离为0
        dist[k] = 0;
        // 遍历边，严格的n - 1轮
        for (int round = 1; round <= n - 1; round++) {
            // 这一轮有没有更新过
            boolean updated = false;
            for (int[] edge : times) {
                int x = edge[0];
                int y = edge[1];
                int z = edge[2];
                if (dist[x] + z < dist[y]) {
                    dist[y] = dist[x] + z;
                    updated = true;
                }
            }
            // 如果这轮没有更新过，则直接退出循环
            if (!updated) break;
        }
        int ans = 0;
        for (int i = 1; i <= n; i++) {
            ans = Math.max(ans, dist[i]);
        }
        return ans == Integer.MAX_VALUE / 2 ? -1 : ans;
    }
}
```

总结：Dijkstra 算法需要自己建图，而 Bellman-Ford 算法不需要自己建图；Dijkstra 算法需要遍历点，而 Bellman-Ford 算法需要遍历边。

## SPFA 算法

最短路径快速算法（Shortest Path Faster Algorithm (SPFA)），即带有队列优化的 Bellman-Ford 算法。是一个用于求解有向带权图单源最短路径的算法。这一算法在随机的稀疏图上表现出色，并且适用于带有负边权的图。

1. 用`dist`数组记录点到有向图的任意一点距离，初始化起点距离为 0，其余点均为 INF，起点入队。
2. 判断该点是否存在。（未存在就入队，标记）
3. 队首出队，并将该点标记为没有访问过，方便下次入队。
4. 遍历以对首为起点的有向边（t,i）,如果`dist[i] > dist[t] + w(t,i)`,则更新`dist[i]`。
5. 如果 i 不在队列中，则入队标记，一直到循环为空。

时间复杂度：一般`O(m)`，最坏`O(nm)`
伪代码：
`s: 起点`, `w(u, v): 边(u, v)的权重`, `Q: 队列`

```java
procedure SPFA(G, s)
    for each vertex v ≠ s in V(G)
        dist(v) := ∞
    dist(s) := 0
    offer s into Q
    while Q is not empty
        u := poll Q
        for each edge (u, v) in E(G)
            if dist(u) + w(u, v) < dist(v) then
                dist(v) := dist(u) + w(u, v)
                if v is not in Q then
                    offer v into Q
```

例题：[743. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/description/)

```java
class Solution {
    public int networkDelayTime(int[][] times, int n, int k) {
        int INF = Integer.MAX_VALUE / 2;
        int[][] g = new int[n + 1][n + 1];
        for (int i = 1; i <= n; i++) {
            Arrays.fill(g[i], INF);
        }
        for (int[] edge : times) {
            int x = edge[0];
            int y = edge[1];
            int z = edge[2];
            g[x][y] = Math.min(g[x][y], z);
        }

        int[] dist = new int[n + 1];
        Arrays.fill(dist, INF);
        dist[k] = 0;

        boolean[] inQueue = new boolean[n + 1];
        Queue<Integer> q = new ArrayDeque<>();
        q.offer(k);
        inQueue[k] = true;
        while (!q.isEmpty()) {
            int u = q.poll();
            inQueue[u] = false;
            for (int v = 1; v <= n; v++) {
                if (g[u][v] == INF) continue;
                if (dist[u] + g[u][v] < dist[v]) {
                    dist[v] = dist[u] + g[u][v];
                    if (!inQueue[v]) {
                        q.offer(v);
                        inQueue[v] = true;
                    }
                }
            }
        }
        int ans = 0;
        for (int i = 1; i <= n; i++) {
            ans = Math.max(ans, dist[i]);
        }
        return ans == INF ? -1 : ans;
    }
}
```

## Floyd 算法

例题：[854. Floyd 求最短路](https://www.acwing.com/problem/content/856/)

```java
import java.util.*;

class Main {
    static int INF = Integer.MAX_VALUE / 2;
    static int n;
    static int[][] g;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        int m = sc.nextInt();
        int k = sc.nextInt();
        g = new int[n + 1][n + 1];
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (i == j) g[i][j] = 0;
                else g[i][j] = INF;
            }
        }
        while (m-- > 0) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            int c = sc.nextInt();
            g[a][b] = Math.min(g[a][b], c);
        }
        floyd();
        while (k-- > 0) {
            int x = sc.nextInt();
            int y = sc.nextInt();
            int t = g[x][y];
            if (t > INF / 2) System.out.println("impossible");
            else System.out.println(t);
        }
    }

    public static void floyd() {
        for (int k = 1; k <= n; k++) {
            for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= n; j++) {
                    g[i][j] = Math.min(g[i][j], g[i][k] + g[k][j]);
                }
            }
        }
    }
}
```

## Prim 算法

![image.png](https://cdn.nlark.com/yuque/0/2022/png/25849280/1671419578754-61a47918-4142-4839-a984-c048eab3a49f.png#averageHue=%23fefefe&clientId=u353510c5-64cf-4&from=paste&height=394&id=ud66855ab&name=image.png&originHeight=788&originWidth=1282&originalType=binary&ratio=1&rotation=0&showTitle=false&size=278151&status=done&style=none&taskId=u65980384-e028-468d-9d25-8281d02bd46&title=&width=641)
![image.png](https://cdn.nlark.com/yuque/0/2022/png/25849280/1671433259938-ea510c17-5708-4b01-9559-ecbcd972c15d.png#averageHue=%23fdfdfd&clientId=u353510c5-64cf-4&from=paste&height=218&id=ub4a20d08&name=image.png&originHeight=436&originWidth=2614&originalType=binary&ratio=1&rotation=0&showTitle=false&size=192702&status=done&style=none&taskId=u20d1fc6b-e16c-4365-9b79-1ee250eebc4&title=&width=1307)

# 数学知识

## 质数

例题：[866. 试除法判定质数](https://www.acwing.com/problem/content/868/)

```java
public static boolean isPrime(int n) {
    if (n < 2) return false;
    for (int i = 2; i <= n / i; i++) {
        if (n % i == 0) return false;
    }
    return true;
}
```

例题：[867. 分解质因数](https://www.acwing.com/problem/content/869/)

> 给定 n 个正整数，将每个数分解质因数，并按照质因数从小到大的顺序输出每个质因数的底数和指数。

```java
import java.util.*;

class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        while (n-- > 0) {
            int x = sc.nextInt();
            factorization(x);
        }
    }

    public static void factorization(int n) {
        for (int i = 2; i <= n / i; i++) {
            int count = 0;
            while (n % i == 0) {
                n /= i;
                count++;
            }
            if (count > 0) System.out.printf("%d %d\n", i, count);
        }
        if (n > 1) System.out.printf("%d %d\n", n, 1);
        System.out.println();
    }
}
```

埃氏筛：
例题：[204. 计数质数](https://leetcode.cn/problems/count-primes/description/)

> 给定整数 n ，返回 所有小于非负整数 n 的质数的数量

```java
class Solution {
    public int countPrimes(int n) {
        boolean[] isPrime = new boolean[n + 1];
        Arrays.fill(isPrime, true);
        int ans = 0;
        for (int i = 2; i <= n / i; i++) {
            // 由于所有的合数都是质数的倍数，因此只要筛质数的倍数即可
            if (isPrime[i]) {
                for (int j = i + i; j < n; j += i) {
                    isPrime[j] = false;
                }
            }
        }
        for (int i = 2; i < n; i++) {
            if (isPrime[i]) ans++;
        }
        return ans;
    }
}
```

## 约数

例题：[869. 试除法求约数](https://www.acwing.com/problem/content/871/)

```java
import java.util.*;

class Main {
    static List<Integer> ans;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        ans = new ArrayList<>();
        while (n-- > 0) {
            int x = sc.nextInt();
            ans.clear();
            getDivisors(x);
            Collections.sort(ans);
            for (int i : ans) {
                System.out.print(i + " ");
            }
            System.out.println();
        }
    }

    public static void getDivisors(int n) {
        for (int i = 1; i <= n / i; i++) {
            if (n % i == 0) {
                ans.add(i);
                if (i != n / i) ans.add(n / i);
            }
        }
    }
}
```

例题：[870. 约数个数](https://www.acwing.com/problem/content/872/)
对于一个大于 1 的正整数 n，可以分解质因数：
$n=\prod_{i=1}^k p_i^{a_i}=p_1^{a_1} \cdot p_2^{a_2} \cdots p_k^{a_k}$
则 n 的正约数的个数就是：
$f(n)=\prod_{i=1}^k\left(a_i+1\right)=\left(a_1+1\right)\left(a_2+1\right) \cdots\left(a_k+1\right)$

```java
import java.util.*;

class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        Map<Integer, Integer> primes = new HashMap<>();
        while (n-- > 0) {
            int x = sc.nextInt();
            for (int i = 2; i <= x / i; i++) {
                while (x % i == 0) {
                    x /= i;
                    primes.put(i, primes.getOrDefault(i, 0) + 1);
                }
            }
            if (x > 1) {
                primes.put(x, primes.getOrDefault(x, 0) + 1);
            }
        }
        long ans = 1;
        for (int prime : primes.values()) {
            ans = ans * (prime + 1) % ((int)1e9 + 7);
        }
        System.out.println(ans);
    }
}
```

最大公约数 & 最小公倍数

```java
private int gcd(int a, int b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}

private int lcm(int a, int b) {
    return a * b / gcd(a, b);
}
```

## 同余定理

两个数 x 和 y，如果 (x−y)  mod  p = 0，则称 x 与 y 对模 p 同余，那么：
$x \mod p = y \mod p$

负数取模：如果 x < 0，y >= 0
$x \mod p + p = y \mod p$

## 快速幂

例题：[372. 超级次方](https://leetcode.cn/problems/super-pow/description/), [50. Pow(x, n)](https://leetcode.cn/problems/powx-n/)

```java
public long qpow(int a, int b, int p) {
    long ans = 1L;
    while (b > 0) {
        if (b % 2 == 1) {
            ans = ans * a % p;
        }
        a = a * a % p;
        b /= 2;
    }
    return ans;
}
```

## 博弈论

例题：[292. Nim 游戏](https://leetcode.cn/problems/nim-game/), [877. 石子游戏](https://leetcode.cn/problems/stone-game/), [319. 灯泡开关](https://leetcode.cn/problems/bulb-switcher/)

# 贪心

## 区间问题

例题：[905. 区间选点](https://www.acwing.com/problem/content/907/), [908. 最大不相交区间数量](https://www.acwing.com/problem/content/910/), ⭐ [435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/description/)
为什么要按照右端点排序？因为无重叠区间问题本质是一个**会议问题**，按照右端点进行排序能够找到最早结束的会议，也就能给后面预留更多的时间。而如果按照左端点排序，则只能找到最早开始的会议，而不一定是最早结束的。例：

```
|_________|                  区间a
  |___|                      区间b
       |__|                  区间c
            |______|         区间d
```

```java
// 贪心区间问题模板题：求最大不相交区间数量
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        // 重点：按照右端点排序
        Arrays.sort(intervals, (a, b) -> a[1] - b[1]);
        int count = 0;
        int right = Integer.MIN_VALUE;
        for (int i = 0; i < intervals.length; i++) {
            if (intervals[i][0] >= right) {
                count++;
                right = intervals[i][1];
            }
        }
        return intervals.length - count;
    }
}
```

例题：⭐ [2406. 将区间分为最少组数](https://leetcode.cn/problems/divide-intervals-into-minimum-number-of-groups/description/)
按照左端点`left`排序后，用最小堆模拟，堆顶存储每个组最后一个区间的`right`。
遍历区间：

- 如果当前的`left`大于堆顶，则可以接在这个组的末尾，更新堆顶为`right`；
- 否则需要创建一个新的组。

```java
class Solution {
    public int minGroups(int[][] intervals) {
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        for (int[] p : intervals) {
            if (!pq.isEmpty() && pq.peek() < p[0]) {
                pq.poll();
            }
            pq.offer(p[1]);
        }
        return pq.size();
    }
}
```

例题：[907. 区间覆盖](https://www.acwing.com/problem/content/909/)
解题思路：

1. 将所有的区间按照左端点从小到大排序
2. 找到所有左端点小于等于当前要覆盖区间起点的线段，并取其中右端点最大的线段
3. 将起点更新为最大右端点

```java
import java.util.*;

class Range {
    int l, r;
    public Range(int l, int r) {
        this.l = l;
        this.r = r;
    }
}

class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int s = sc.nextInt();
        int t = sc.nextInt();
        int n = sc.nextInt();
        Range[] ranges = new Range[n];
        for (int i = 0; i < n; i++) {
            int l = sc.nextInt();
            int r = sc.nextInt();
            ranges[i] = new Range(l, r);
        }
        // 按区间的左端点排序
        Arrays.sort(ranges, (a, b) -> {return a.l - b.l;});
        int ans = 0;
        boolean flag = false;
        for (int i = 0, j = 0; i < n; i++) {
            int r = Integer.MIN_VALUE;
            // 在所有包含起点s的区间中找到右端点最大的
            while (j < n && ranges[j].l <= s) {
                r = Math.max(r, ranges[j].r);
                j++;
            }
            // 保证下次循环从j开始
            i = j - 1;
            // 如果最大的右端点都比起点小，则直接break
            if (r < s) {
                ans = -1;
                break;
            }
            ans++;
            // 如果此时右端点已经大于终点了，则直接break
            if (r >= t) {
                flag = true;
                break;
            }
            // 把起点更新为最大的右端点
            s = r;
        }
        if (!flag) ans = -1;
        System.out.println(ans);
    }
}
```
